
> python不允许程序员选择采用值传递还是引用传递。

> 如果函数参数收到的是**一个可变对象，如字典或者列表，那就是引用**，能修改对象的值。

> 但如果收到的是**一个不可变对象，如数字、字符或者元组，那就是值传递**，不能直接修改。

> 所以说，程序员不能自己控制，完全取决于你传递的参数是什么类型。

> 为了简化内存管理，Python通过引用计数机制实现自动垃圾回收功能。

 
# 列表
```
>>> def add_list(p):
...      p = p + [1]
... 
>>> pl = [1,2,3]
>>> add_list(pl)
>>> print(pl)
[1, 2, 3]
>>> 
```
```
>>> def add_list(p):
...     p += [1]
... 
>>> pl = [1,2,3]
>>> add_list(pl)
>>> print(pl)
[1, 2, 3, 1]
>>> 
```
> “=”操作符会新建一个新的变量保存赋值结果，然后再把引用名指向“=”左边，即修改了原来的p引用，使p成为指向新赋值变量的引用。

> 而“+=”则不会，直接修改了原来p引用的内容，事实上+=和=在python内部使用了不同的实现函数。
 
# 词典
```
>>> a=[]
>>> b={'num':0,'sqrt':0}
>>> resurse = [1,2,3]
>>> for i in resurse:
...     b['num'] = i
...     b['sqrt'] = i * i
...     a.append(b)
... 
>>> print(a)
[{'num': 3, 'sqrt': 9}, {'num': 3, 'sqrt': 9}, {'num': 3, 'sqrt': 9}]
>>> 
```
但我们想要的是：
```
[{'num': 1, 'sqrt': 1}, {'num': 2, 'sqrt': 4}, {'num': 3, 'sqrt': 9}]
```
可以用id函数查看一下a和b:
```
>>> id(a)
110618696
>>> id(b)
108185928
>>> id(a[0])
108185928
>>> id(a[1])
108185928
>>> id(a[2])
108185928
>>> 
```
显然，a中的三个元素是一样的，就是b的引用~而最后的b的值，是最后执行的结果。可以修改为：
```
>>> a=[]
>>> b={'num':0,'sqrt':0}
>>> resurse = [1,2,3]
>>> for i in resurse:
...     a.append({"num": i, "sqrt": i * i})
... 
>>> print(a)
[{'num': 1, 'sqrt': 1}, {'num': 2, 'sqrt': 4}, {'num': 3, 'sqrt': 9}]
>>> 
```
# 数字
```
>>> n=2
>>> def add(n):
...     n=n+1
...     return n
... 
>>> add(n)
3
>>> print(n)
2
>>> 
```
> n没有被修改
